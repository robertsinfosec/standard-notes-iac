#!/bin/bash
# Ansible managed - MOTD backups section
# Generated from roles/motd/templates/30-backups.j2

# Load helpers
source /usr/local/bin/motd-helpers/colors.sh 2>/dev/null || true
source /usr/local/bin/motd-helpers/formatters.sh 2>/dev/null || true

# Configuration
BACKUP_DIR="{{ motd_backup_directory }}"
TIMEOUT={{ motd_script_timeout }}

# Print section header
print_section_header "BACKUPS"

# Find most recent backup file
if [[ ! -d "$BACKUP_DIR" ]]; then
    printf "  %-17s %b\n" "Last Backup:" "${RED}${SYM_ERROR}${NC} Backup directory does not exist"
    printf "  %-17s %s\n" "Location:" "$BACKUP_DIR (missing)"
    printf "  %-17s %b\n" "Status:" "${RED}${SYM_ERROR}${NC} Backups not configured"
    exit 0
fi

latest_backup=$(find "$BACKUP_DIR" -name 'sn-*.tar.gz' -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)

if [[ -z "$latest_backup" ]]; then
    printf "  %-17s %b\n" "Last Backup:" "${RED}${SYM_ERROR}${NC} No backups found"
    printf "  %-17s %s\n" "Location:" "$BACKUP_DIR (empty)"
    printf "  %-17s %b\n" "Status:" "${RED}${SYM_ERROR}${NC} No backups exist - run backup immediately!"
else
    # Get backup timestamp
    backup_timestamp=$(stat -c '%y' "$latest_backup" 2>/dev/null | cut -d. -f1)
    
    if [[ -n "$backup_timestamp" ]]; then
        # Calculate time ago
        backup_epoch=$(date -d "$backup_timestamp" +%s 2>/dev/null)
        now_epoch=$(date +%s)
        
        if [[ -n "$backup_epoch" ]] && (( backup_epoch > 0 )); then
            diff_seconds=$((now_epoch - backup_epoch))
            diff_hours=$((diff_seconds / 3600))
            
            # Format time ago with age-based coloring
            if (( diff_seconds < 3600 )); then
                minutes=$((diff_seconds / 60))
                time_ago="${minutes}m ago"
                age_indicator=""
            elif (( diff_seconds < 86400 )); then
                hours=$((diff_seconds / 3600))
                minutes=$(((diff_seconds % 3600) / 60))
                time_ago="${hours}h ${minutes}m ago"
                age_indicator=""
            elif (( diff_hours < 48 )); then
                days=$((diff_seconds / 86400))
                hours=$(((diff_seconds % 86400) / 3600))
                time_ago="${days}d ${hours}h ago"
                age_indicator=""
            else
                # Backup older than 48h - warning!
                days=$((diff_seconds / 86400))
                hours=$(((diff_seconds % 86400) / 3600))
                time_ago="${days}d ${hours}h ago"
                age_indicator=" ${YELLOW}${SYM_WARNING}${NC}"
            fi
            
            printf "  %-17s %s (%b%s%b)\n" "Last Backup:" "$backup_timestamp" "$age_indicator" "$time_ago" "$NC"
        else
            printf "  %-17s %s\n" "Last Backup:" "$backup_timestamp"
        fi
    else
        printf "  %-17s %s\n" "Last Backup:" "${YELLOW}${SYM_WARNING}${NC} Unable to read timestamp"
    fi
    
    # Get backup location (filename only for brevity)
    backup_filename=$(basename "$latest_backup")
    printf "  %-17s %s/%s\n" "Location:" "$BACKUP_DIR" "$backup_filename"
    
    # Get backup size
    backup_size=$(du -h "$latest_backup" 2>/dev/null | awk '{print $1}')
    if [[ -n "$backup_size" ]]; then
        printf "  %-17s %s\n" "Size:" "$backup_size"
    else
        printf "  %-17s %s\n" "Size:" "${YELLOW}${SYM_WARNING}${NC} Unable to determine"
    fi
    
    # Validate backup integrity and check age
    integrity_ok=false
    if timeout "$TIMEOUT" gzip -t "$latest_backup" 2>/dev/null; then
        integrity_ok=true
    fi
    
    # Determine status based on integrity and age
    if [[ "$integrity_ok" == "true" ]]; then
        if (( diff_hours < 48 )); then
            printf "  %-17s %b\n" "Status:" "${GREEN}${SYM_SUCCESS} Valid backup${NC}"
        else
            printf "  %-17s %b\n" "Status:" "${YELLOW}${SYM_WARNING} Valid but stale (>48h old)${NC}"
        fi
    else
        printf "  %-17s %b\n" "Status:" "${RED}${SYM_ERROR} Backup may be corrupted${NC}"
    fi
fi
